---
layout: post
comments: true
date: 2014-12-09 23:30:41+00:00
title: 高性能Web缓存浅析
categories:  
- system
- programming
- web

---
# 目录 
* [1. 动态内容缓存](#dynamic_content_cache)
* [2. 浏览器缓存](#browser_content_cache)
* [3. 服务器缓存](#server_cache)
* [4. 反向代理缓存](#reserve_proxy_cache)
* [5. 分布式缓存](#distribute_cache)
* [6. 总结](#summary)

本文标题叫“高性能Web缓存浅析”，首先，必须声明，“浅析”并非自己谦虚，而是真的是“浅”析，作为一枚刚毕业应届生，在提笔写这篇文章前一周刚上线了自己作为程序员的第一个正式系统，文中所有内容均来源于阅读和自己的一些思考，与实际生产环境可能会有出入，还请不吝赐教。

缓存的思想由来已久，将需要花费大量时间开销的计算结果保存起来，在以后需要的时候直接使用，避免重复计算。在计算机系统中，缓存的应用不胜枚举，比如计算机的三级存储结构、Web 服务中的缓存，本文主要讨论缓存在 Web 环境中的使用，包括浏览器缓存、服务器缓存、反向代理缓存以及分布式缓存等方面。

# <a id="dynamic_content_cache">  1. 动态内容缓存 </a>
现代 Web 站点更多的提供动态内容，如动态网页、动态图片、Web服务等，它们通常在 Web 服务器端进行计算，生成 HTML 并返回。在生成 HTML 页面的过程中，涉及到大量的 CPU 计算和 I/O 操作，比如数据库服务器的 CPU 计算和磁盘 I/O，以及与数据库服务器通信的网络I/O。这些操作会花费大量时间，然而，大多数情况下，动态网页在多次请求时的生成结果几乎一样，那么，就可以考虑通过缓存去掉这部分时间开销。

## 1.1 页面缓存 
对于动态网页来说，我们将生成的 HTML 缓存起来，称为页面缓存(Page Cache)，对于其它动态内容如动态图片、动态 XML 数据，我们也可以相同策略将它们的结果整体进行缓存。

对于页面缓存具体方法，有很多实现方法，如类似 Smarty 的模板引擎或者类似 Zend、Diango 的 MVC 框架，控制器和视图分离，控制器很方便的拥有自己的缓存控制权。
### 1.1.1 存储方式
通常，我们将动态内容的缓存**存储在磁盘**上，磁盘提供了廉价的、存储大量文件的方式，不用担心由于空间问题而淘汰缓存。但是，还是可能造成 cache 目录下存在大量缓存文件的可能，从而使 CPU 在遍历目录时花费大量时间，针对这个问题，可以使用缓存目录分级来解决这一问题，从而将每个目录下的子目录或文件数量控制在少量范围内。比如，原来的缓存全部在 cache 目录下，缓存文件如下所示:
> cache/abc-111-post.htm

采用目录分级的方式来存储缓存文件后，缓存文件变为:
> cache/abc/111/post.htm

这样，在存储大量缓存文件的情况下，可以减少 CPU 遍历目录的时间消耗。

动态内容被缓存下来了，那么，既然内容是动态生成的，就有可能会发生变化，所以，动态内容的缓存机制**必须能判断缓存何时过期，何时需要生成新的缓存**，缓存过期检查策略主要是两种机制：

1. 根据缓存创建时间、缓存有效期设置的时间长度以及当前时间，来判断是否过期，也就是说如果当前时间距缓存创建的时间长度超过有效期长度，则认为缓存过期。
2. 根据缓存的过期时间和当前时间来判断。

除了上述的存储方式，还可以**将缓存放在内存中**。当缓存存放在磁盘文件中时，缓存加载和过期检查都会带来一定的磁盘 I/O 开销，同时，本身也会受到磁盘负载的影响，所以，可以将缓存放到本机内存中，借助 PHP 的 APC 模块或 PHP 缓存扩展 XCache 可以很方便的实现，除此之外，还可以将缓存存储到独立的缓存服务器中，比如利用 memcached，可以很方便的通过 TCP 将缓存存储到其他服务器中。虽然使用 memcached，速度会比使用本机内存稍慢，但相比将缓存存放到本机内存，使用 memcached 来实现缓存有两个优势：

1. Web 服务器内存曝光，无法提供大量空间做 HTML 缓存。
2. 使用独立的缓存服务器可以提供良好的可扩展性。

## 1.2 局部无缓存

## 1.3 静态化内容

                                                  

# <a id="browser_content_cache">  2. 浏览器缓存</a>



# <a id="server_cache">  3. 服务器缓存</a>





# <a id="reserve_proxy_cache">  4. 反向代理缓存</a>

# <a id="distribute_cache">  5. 分布式缓存</a>

# <a id="summary">  6.总结</a>




[1]: