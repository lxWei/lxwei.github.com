---
layout: post
comments: true
date: 2014-12-09 23:30:41+00:00
title: 高性能Web缓存浅析
categories:  
- system
- programming
- web

---
# 目录 
* [1. 动态内容缓存](#dynamic_content_cache)
* [2. 浏览器缓存](#browser_content_cache)
* [3. 服务器缓存](#server_cache)
* [4. 反向代理缓存](#reserve_proxy_cache)
* [5. 分布式缓存](#distribute_cache)
* [6. 总结](#summary)

本文标题叫“高性能Web缓存浅析”，首先，必须声明，“浅析”并非自己谦虚，而是真的是“浅”析，作为一枚刚毕业应届生，在提笔写这篇文章前一周刚上线了自己作为程序员的第一个正式系统，文中所有内容均来源于阅读和自己的一些思考，与实际生产环境可能会有出入，还请不吝赐教。

首先，简单说下缓存，缓存的思想由来已久，将需要花费大量时间开销的计算结果保存起来，在以后需要的时候直接使用，避免重复计算。在计算机系统中，缓存的应用不胜枚举，比如计算机的三级存储结构、Web 服务中的缓存，本文主要讨论缓存在 Web 环境中的使用，包括浏览器缓存、服务器缓存、反向代理缓存以及分布式缓存等方面。

# <a id="dynamic_content_cache">  1. 动态内容缓存 </a>
现代 Web 站点更多的提供动态内容，如动态网页、动态图片、Web服务等，它们通常在 Web 服务器端进行计算，生成 HTML 并返回。在生成 HTML 页面的过程中，涉及到大量的 CPU 计算和 I/O 操作，比如数据库服务器的 CPU 计算和磁盘 I/O，以及与数据库服务器通信的网络I/O。这些操作会花费大量时间，然而，大多数情况下，动态网页在多次请求时的生成结果几乎一样，那么，就可以考虑通过缓存去掉这部分时间开销。

## 1.1 页面缓存 
对于动态网页来说，我们将生成的 HTML 缓存起来，称为页面缓存(Page Cache)，对于其它动态内容如动态图片、动态 XML 数据，我们也可以相同策略将它们的结果整体进行缓存。

对于页面缓存具体方法，有很多实现方法，如类似 Smarty 的模板引擎或者类似 Zend、Diango 的 MVC 框架，控制器和视图分离，控制器很方便的拥有自己的缓存控制权。
### 1.1.1 存储方式
通常，我们将动态内容的缓存**存储在磁盘**上，磁盘提供了廉价的、存储大量文件的方式，不用担心由于空间问题而淘汰缓存，这是一种简单且容易部署的方法。但是，还是可能造成 cache 目录下存在大量缓存文件的可能，从而使 CPU 在遍历目录时花费大量时间，针对这个问题，可以使用缓存目录分级来解决这一问题，从而将每个目录下的子目录或文件数量控制在少量范围内。这样，在存储大量缓存文件的情况下，可以减少 CPU 遍历目录的时间消耗。

当将缓存数据存储在磁盘文件中时，每次缓存加载和过期检查都存在磁盘 I/O 开销，同时也受磁盘负载影响，如果磁盘 I/O 负载大，则缓存文件的 I/O 操作会存在一定的延迟。

另外，可以**将缓存放在本机内存中**，借助 PHP 的 APC 模块或 PHP 缓存扩展 XCache 可以很方便的实现，这样，加载缓存时就没有任何磁盘 I/O 操作。

最后，还可以将缓存存储在**独立的缓存服务器中**，利用 memcached 可以很方便的通过 TCP 将缓存存储在其他服务器。使用 memcached，速度会比使用本机内存稍慢，但相比将缓存存放到本机内存，使用 memcached 来实现缓存有两个优势：

1. Web 服务器内存宝贵，无法提供大量空间做 HTML 缓存。
2. 使用独立的缓存服务器可以提供良好的可扩展性。


### 1.1.2 过期检查
既然谈到缓存，就不得不谈过期检查，缓存过期检查主要根据**缓存有效期**机制来检查，主要两种机制：

1. 根据缓存创建时间、缓存有效期设置的时间长度以及当前时间，来判断是否过期，也就是说如果当前时间距缓存创建的时间长度超过有效期长度，则认为缓存过期。
2. 根据缓存的过期时间和当前时间来判断。

对于缓存有效期的设置并不是件容易的事，如果太长，虽然缓存命中率高了，但动态内容更新不及时；如果太短，虽然动态内容更新及时，但缓存命中率降低了。所以，设置合理的有效期十分重要，但更重要的是，我们需要具备能意识到有效期何时需要变换的能力，然后在任何时候找到合适的取值。

除了缓存有效期，缓存还提供了**随时强行清除缓存**的控制方法。
### 1.1.3 局部无缓存
在有些情况下，需要页面中某块区域的内容及时更新，如果因为一块区域需要及时更新而重建整个页面缓存的话，会显得不值得。在流行的模板框架中，都提供了局部无缓存的支持，如 Smary。

## 1.2 静态化内容
前面的方法需动态地控制是否使用缓存，静态化方法将动态内容生成静态内容，然后让用户直接请求静态内容，大幅度提高吞吐率。

同样的，对于静态化内容，同样需要更新，一般有两种方法：

1. 数据更新时重新生成静态化内容。
2. 定时重新生成静态化内容。

与前面提到的动态缓存一样，静态页面也可以不更新整个页面，可以通过服务器包含(SSI)技术实现各个局部页面的独立更新，从而大大减少重建整个页面的计算开销和磁盘 I/O 开销，以及分发时的网络 I/O 开销。现在主流的 Web 服务器都支持 SSI 技术，比如 Apache、lighttpd等。

                                                  

# <a id="browser_content_cache">  2. 浏览器缓存</a>
串通角度来看，人们习惯将浏览器仅仅看着 PC 上的一个软件，但实际上，**浏览器是 Web 站点的重要组成部分**。如果将内容缓存在浏览器上，不仅可以减少服务器计算开销，还能避免不必要的传输和带宽浪费。为了在浏览器端存储缓存内容，一般是在用户的文件系统中创建一个目录用来存储缓存文件，并给每个缓存文件打上一些必要标签，如过期时间等。另外，不同浏览器在存储缓存文件时会有细微差别。

## 2.1 实现
浏览器缓存内容存储在浏览器端，而内容由 Web 服务器生成，要利用浏览器缓存，浏览器和 Web 服务器之间必须沟通，这就是 HTPP 中的“缓存协商”。

### 2.1.1 缓存协商
当 Web 服务器接收到浏览器请求后，Web 服务器需要告知浏览器哪些内容可以缓存，一旦浏览器知道哪些内容可以缓存后，下次当浏览器需要请求这个内容时，浏览器便不会直接向服务器请求完整内容，二是询问服务器是否可以使用本地缓存，服务器在收到浏览的询问后回应是使用浏览器本地缓存还是将最新内容传回给浏览器。


# <a id="server_cache">  3. 服务器缓存</a>





# <a id="reserve_proxy_cache">  4. 反向代理缓存</a>

# <a id="distribute_cache">  5. 分布式缓存</a>

# <a id="summary">  6.总结</a>




[1]: